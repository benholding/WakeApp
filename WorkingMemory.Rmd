---
title: "SleSI_workingmemory"
author: "Benjamin Holding"
date: 'Last Updated: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
ipak <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
} #function to see if package is installed. Will download if not, and then opens it.

packages <- c("data.table", "lubridate", "anytime", "dplyr", "ggplot2", "nlme", "tidyr", "lme4", "lmerTest") #These are the extra packages needed to merge the CSV files
suppressPackageStartupMessages(ipak(packages))
```


```{r, include=FALSE}

myoriginalwd <- getwd()
setwd("Working memory") #enter the location of the data here between quotation marks
file_list <- list.files()
L <- length(file_list) 

WM_list <- lapply(file_list, read.csv, header=T, sep=",", dec=".")

setwd(myoriginalwd)
WM.names <- read.csv("WorkingMemory_NewNames.csv", header = F)

names(WM_list) <- WM.names[,1]

final.list <- mapply(cbind, WM_list, "SampleID"=WM.names[,1], SIMPLIFY=F)

WakeApp_WM <- rbindlist(final.list, fill = T) #this is the complete data frame
WakeApp_WM$id <- as.character(WakeApp_WM$id)
WakeApp_WM$id[which(WakeApp_WM$id == "SI_106_2")] <- "SI_106"
WakeApp_WM$id[which(WakeApp_WM$id == "SI_106_3")] <- "SI_106"
WakeApp_WM$id[which(WakeApp_WM$id == "SI_106_4")] <- "SI_106"

WakeApp_WM$id <- as.numeric(gsub("[^0-9]","",WakeApp_WM$id))
colnames(WakeApp_WM)[1] <- "ID"

slesi.key <- read.csv("SleSI_Masterkey.csv")

WakeApp_WM_complete <- inner_join(WakeApp_WM, slesi.key)

WakeApp_WM_complete$SampleID <- gsub("WM_", "", WakeApp_WM_complete$SampleID)
WakeApp_WM_complete$SampleID <- gsub(".csv", "", WakeApp_WM_complete$SampleID)

WM_Complete_TIDY <- WakeApp_WM_complete[c(-1,-2,-3)] %>% 
  separate(SampleID, into = c("ID", "time"), sep = "\\_")
                             
WM_Complete_TIDY$time <- as.integer(WM_Complete_TIDY$time)

```

##remove problem responses
(must respond between 0.1 and 10 seconds)
```{r}
WM_Complete_TIDY <- WM_Complete_TIDY[which(WM_Complete_TIDY$response_time > 0.1 & WM_Complete_TIDY$response_time < 10),]
```


#Working memory Correct score analysis
###Assessing the best growth curve model
```{r}
# assessing the best time polynomial
model.3a<-glmer(correct~1 + (1|ID), data=WM_Complete_TIDY, family=binomial)
model.3b<-glmer(correct~time + (1|ID), data=WM_Complete_TIDY, family=binomial)
model.3c<-glmer(correct~time + I(time^2) + (1|ID), data=WM_Complete_TIDY, family=binomial)
model.3d<-glmer(correct~time + I(time^2) + I(time^3) + (1|ID), data=WM_Complete_TIDY, family=binomial)

anova(model.3a, model.3b, model.3c,model.3d) #the normal linear model is the best (but the quadratic is nearly significant)

summary(model.3b)

#additing in fixed variables

model.4a<-glmer(correct~time + (1|ID), data=WM_Complete_TIDY, family=binomial) 
model.4b<-glmer(correct~time +SD + (1|ID), data=WM_Complete_TIDY, family=binomial)
model.4c<-glmer(correct~time*SD + (1|ID), data=WM_Complete_TIDY, family=binomial)

anova(model.4a,model.4b, model.4c) #best to add SD:time interaction as predictor

# Is it worthwhile adding a random effect of time within individuals?
model.5a<-glmer(correct~time*SD + (1|ID), data=WM_Complete_TIDY, family=binomial) 
# model.5b<-glmer(correct~time*SD + (time|ID), data=WM_Complete_TIDY, family=binomial) # doesn't converge
#anova(model.5a,model.5b) #Model 5b doesn't converge so stick to 6a
```

###Best Model
There is an interaction between the condition and linear effect of time
```{r}
#best model (pure linear model with SleepCondition interacting with time)
summary(model.5a)
```

###plotting the raw data and best model
```{r}
WM_Complete_TIDY$SD <- as.factor(WM_Complete_TIDY$SD)

WM.final.model <-glmer(correct~time*SD + (1|ID), data=WM_Complete_TIDY, family=binomial)

#raw data plot with 95% confidence intervals
ggplot(WM_Complete_TIDY, aes(time, correct, colour=SD)) + 
  stat_summary(fun.data=mean_cl_normal, fun.args=list(conf.int=0.95), geom="pointrange") + 
  labs(y="correct", x="Time point") + 
  theme_bw() + scale_color_manual(values=c("red", "blue")) +
  ggtitle("Working Memory raw data plot with 95% confidence intervals") + 
  stat_summary(fun.y=mean, geom="line") 

#fitted model (aka predictive values) plot with 95% confidence intervals
ggplot(WM_Complete_TIDY, aes(time, correct, colour=SD)) + 
  ggtitle("Working memory model fitted (predicted) data plot with 95% confidence intervals") +
  labs(y="Working memory (correct score)", x="Time point") + 
  theme_bw() + stat_summary(aes(y=fitted(WM.final.model)), fun.data=mean_cl_normal, fun.args=list(conf.int=0.95), geom="pointrange") + stat_smooth(method = "lm")
```

#Working Memory RT analysis
###Assessing the best growth curve model
```{r}

WM_complete_correct <- WM_Complete_TIDY[which(WM_Complete_TIDY$correct == 1),]

# assessing the best time polynomial
model.7a<-lme(response_time~1, random=~1|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.7b<-lme(response_time~time, random=~1|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.7c<-lme(response_time~time+I(time^2), random=~1|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.7d<-lme(response_time~time+I(time^2)+I(time^3), random=~1|ID, data=WM_complete_correct, na.action=na.omit, method="ML") 

anova(model.7a, model.7b, model.7c, model.7d) #best to have quadratic effect

# assessing the best random effects term
model.8a<-lme(response_time~time+I(time^2), random=~1|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.8b<-lme(response_time~time+I(time^2), random=~time|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.8c<-lme(response_time~time+I(time^2), random=~time+I(time^2)|ID, data=WM_complete_correct, na.action=na.omit, method="ML")

anova(model.8a,model.8b, model.8c) #having random slopes for quadratic is best

#additing in variables can that explain intercept and slope variability
model.9a<-lme(response_time~time+I(time^2), random=~time+I(time^2)|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.9b<-lme(response_time~SD+time+I(time^2), random=~time+I(time^2)|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.9c <-lme(response_time~SD*time+I(time^2), random=~time+I(time^2)|ID, data=WM_complete_correct, na.action=na.omit, method="ML")
model.9d <- lme(response_time~SD*time+SD*I(time^2), random=~time+I(time^2)|ID, data=WM_complete_correct, na.action=na.omit, method="ML")

anova(model.9a,model.9b, model.9c, model.9d) #Best model is the one without SD
```

### best model
SD is not included
```{r}
#best model
summary(model.9a) #Cubic effect of time, but  effect of SD
```

###plotting the data
```{r}
#raw data plot with 95% confidence intervals
ggplot(WM_complete_correct, aes(time, response_time, colour=SD)) + 
  stat_summary(fun.data=mean_cl_normal, fun.args=list(conf.int=0.95), geom="pointrange") + 
  labs(y="Reaction Time (seconds)", x="Time point") + 
  theme_bw() + scale_color_manual(values=c("red", "blue")) +
  ggtitle("Working memory RT raw data plot with 95% confidence intervals") + stat_summary(fun.y=mean, geom="line") 

#fitted model (aka predictive values) plot with 95% confidence intervals
ggplot(WM_complete_correct, aes(time, response_time, colour=SD)) + 
  labs(y="Reaction Time (seconds)", x="Time point") +
  ggtitle("Working memory RT model fitted (predicted) data plot with 95% confidence intervals") + 
  theme_bw() + stat_summary(aes(y=fitted(model.9a)), fun.data=mean_cl_normal, fun.args=list(conf.int=0.95), geom="pointrange") + stat_smooth(method = "lm", formula  =y ~ poly(x,2))
```

